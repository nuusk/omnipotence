/*      =================================================================
 
                                               __
                            __                /\ \__
   ___     ___ ___     ___ /\_\  _____     ___\ \ ,_\    __    ___     ___     __
  / __`\ /' __` __`\ /' _ `\/\ \/\ '__`\  / __`\ \ \/  /'__`\/' _ `\  /'___\ /'__`\
 /\ \L\ \/\ \/\ \/\ \/\ \/\ \ \ \ \ \L\ \/\ \L\ \ \ \_/\  __//\ \/\ \/\ \__//\  __/
 \ \____/\ \_\ \_\ \_\ \_\ \_\ \_\ \ ,__/\ \____/\ \__\ \____\ \_\ \_\ \____\ \____\
  \/___/  \/_/\/_/\/_/\/_/\/_/\/_/\ \ \/  \/___/  \/__/\/____/\/_/\/_/\/____/\/____/
                                   \ \_\
                                    \/_/
 
 
 OpenGL game made as a project for Computer Graphics and Visualization.
 Academir Year: ------- 2016/2017
 Tutor: --------------- Witold Andrzejewski
 Made by: ------------- Piotr Ptak & Krzysztof Tomys
 
 LICENCE: ------------- WTF: do What The Fuck you want with it (just do what the fuck you want)
 
     How to play:
 You are an omnipotent being that can manipulate fabric of space and time.
 You are placed in a strange world, where only cubes can exist. You have the power to seperate youself into two entities. You are a kinfolk. When you activate kin mode, your powers start to show up. Try to enjoy it as long as you can control yourself. Because when you stay in kin mode for a long time, many distortions appear.
 Sorry for ugly coding.
 */

#include <iostream>
#include <cstdlib>
#include <ctime>
#include <math.h>

//GLEW
#define GLEW_STATIC
#include <GL/glew.h>

//GLFW
#include <GLFW/glfw3.h>

//GLM
#include "glm/gtc/type_ptr.hpp"

//SOIL
#include "SOIL2/SOIL2.h"

//SDL2 (for audio only though.)
#include <SDL2_Mixer/SDL_Mixer.h>

//my headers
#include "Shader.h"
#include "Camera.h"
#include "Texture.h"

// Window's size
#define WIDTH 1200
#define HEIGHT 800
int SCREEN_WIDTH, SCREEN_HEIGHT;

//shading and rendering
#define NUMBER_OF_CUBES 22                          //first 20 cubes are big cubes, the next ones are crates
#define HOW_MANY_BIG_CUBES 20                       //just for the moment... this variable is about to go down.

//customizable
#define DEFAULT_SHININESS 35.0f                     //variable applied to object's shader
#define NUMBER_OF_LANTERNS 40000                    //lanterns are point light sources
#define VARIETY_RANGE 0                            //how much we want to interfere with lanterns' positiong generated by algorithm
#define STARTING_LANTERN_HEIGHT -10.0f              //the minimum height of a lantern (no lantern will be placed below that value)
#define LANTERN_SPREAD 5.0f                         //the default distance between the lanterns
#define FULLSCREEN_MODE true                        //self explainatory
#define LANTERN_SIZE 0.3f                          //lanterns are meant to be small, so consider adding a value between 0.1 and 0.5

//level 1 distortion: lantern floating faster
#define LANTERN_FLOATING_SPEED 30                   //how fast are lanterns floating (with sinusoidal distribution)
#define KIN_MODE_LANTERN_ACCELERATION 4.5f          //as a kin, lanterns are starting to float faster, with accelaration given by this parameter

//level 2 distortion: cubes rotating
#define KIN_ROTATING_ACTIVATION_TIME 5.0f          //after how many seconds cubes begin to rotate
#define CUBE_BASE_ROTATION_ANGLE 10                  //this angle parameter is used in kin mode cube rotation
#define CUBE_ROTATION_ACCELARATION 0.2f             //cube angle acceleration

//level 3 distortion: camera disturbances
#define KIN_DISTURBANCE_ACTIVATION_TIME 10.0f       //after how many seconds there are disturbances in camera perspective
#define KIN_CAMERA_DISTURBANCE_VARIANCE 8.0f        //the variance of camera disturbance during kin mode
#define KIN_CAMERA_DISTURBANCE_DEFAULT_VALUE 0.1f   //well, as said, camera disturbance default value
#define KIN_CAMERA_DISTURBANCE_ACCELERATION 0.09f   //level 3 of distortion: disturbance acceleration
#define KIN_CAMERA_DISTURBANCE_MAX_VALUE 515.2f

Mix_Music *soundTrack;
Mix_Music *shepardRissetGlissando;

GLboolean kinfolkMode = false;                      //if this is enabled, the filter is applied to the screen, and we can move as a kin

//boolean values set if the kin distortion is activated
GLboolean kinMusicActivated = false;
GLboolean kinRotatingActivated = false;
GLboolean kinDisturbanceActivated = false;

void keyCallback(GLFWwindow *window, int key, int scancode, int action, int mode);      //keyboard input function
void mouseCallback(GLFWwindow *window, double xPos, double yPos);                       //mouse input function
void doMovement(GLFWwindow *window);                                                    //process the input given by the player
void generateLanternPositions(glm::vec3 *pointLightPositions);                          //automatical generation algorithm for lanterns
void generateLanternSinudoidalVariance(GLfloat *pointLightSinusoidalVariance);          //generation of lanterns floating sinusoidal function
void generateCubesRotationVariance(GLfloat *cubesRotationVariance);                     //generation of cubes rotation variance (so cubes won't have the same rotation angle)
void generateCubesColor(glm::vec3 *cubesColor);
void generateCubesRotationAxis(glm::vec3 *cubesRotationAxis);                           //generation of cubes rotation axis (so cubes won't have the same rotation axis)
void initSystems();
GLfloat updateTime();                                                                   //measure the time from the last frame and update delta time (used in many functions)

Camera camera(glm::vec3(0.0f, 0.0f, 3.0f));                                             //create camera (since this is first person camera, when we move, we actually move the camera)
GLfloat lastX = WIDTH / 2.0f;                                                           //position of cursor from the previous frame. Since we want to place the cursor at the center of the screen, it has a x position of the half of the width
GLfloat lastY = HEIGHT / 2.0f;                                                          //the same thing as with lastX
bool keys[1024];                                                                        //boolean table used for measuring which key is pressed
bool firstMouse = true;                                                                 //when we move the mouse for the first time, update cursor position

GLfloat deltaTime = 0.0f;                                                               //time measured from the last frame (the difference between the last time and current time)
GLfloat lastTime = 0.0f;                                                                //time that passed til the last frame
GLfloat kinTime = 0.0f;                                                                 //how much time we spent in a kin mode (this is important to distortion activations)
GLfloat kinRotationCounter = 0.0f;                                                      //disturbances are becomming more and more visible. this counter is a multiplier for cubes rotation that increases in time
GLfloat kinDisturbanceCounter = 0.0f;                                                   //same thing as with kin rotation counter

glm::vec3 lightPos(0.0f, 0.0f, 0.0f);                                                   //this value stores a center position of all lanterns on the scene

int main() {
    initSystems();
    GLboolean fullScreenMode = FULLSCREEN_MODE;
    
// --------------------- AUDIO -------------------
    Mix_OpenAudio(MIX_DEFAULT_FREQUENCY, MIX_DEFAULT_FORMAT, 2, 4096);                  //4096 is a chunk size, it works pretty well. Don't quote me on that, though.

    soundTrack = Mix_LoadMUS("resources/audio/unknown-place.mp3");
    shepardRissetGlissando = Mix_LoadMUS("resources/audio/shepard-risset.mp3");
    Mix_PlayMusic(soundTrack, -1);                                                      //-1 means loop forever. this soundtrack is stopped, however, when we activate kin mode.
    
// ------------------- END OF AUDIO ----------------
    
    //create window
    GLFWwindow *window = glfwCreateWindow(WIDTH, HEIGHT, "Main Game", fullScreenMode? glfwGetPrimaryMonitor():nullptr, nullptr);
    
    //check if window was created succesfully
    if (window == nullptr) {
        std::cout<<"Failed to create window (GLFW)" <<std::endl;
        glfwTerminate();
        
        return EXIT_FAILURE;
    }
    glfwMakeContextCurrent(window);
    
    //get the actual window size relevant to your screen (must have for retina displays)
    glfwGetFramebufferSize(window, &SCREEN_WIDTH, &SCREEN_HEIGHT);
    
    //set the default input functions
    glfwSetKeyCallback(window, keyCallback);
    glfwSetCursorPosCallback(window, mouseCallback);
    
    //make the cursor disappear
    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
    
    glewExperimental = GL_TRUE;
    if (glewInit() != GLEW_OK) {
        std::cout<<"Failed to initialize GLEW" <<std::endl;
        return EXIT_FAILURE;
    }
    
    //define viewport dimensions
    glViewport(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
    
    glEnable(GL_DEPTH_TEST);
    
    //image blending
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    
    // ======= SHADER SETUP ========
    Shader _lightShader("resources/shaders/light.vs", "resources/shaders/light.fs");
    Shader _lanternShader("resources/shaders/lantern.vs", "resources/shaders/lantern.fs");
    Shader _skyboxShader("resources/shaders/skybox.vs", "resources/shaders/skybox.fs");
    
    // Set up vertex data (and buffer(s)) and attribute pointers
    // use with perspective projection
    GLfloat vertices[] = {
        //positions             //normals               //texture Coords
        -0.5f, -0.5f, -0.5f,    0.0f,  0.0f, -1.0f,     0.0f,  0.0f,
        0.5f, -0.5f, -0.5f,     0.0f,  0.0f, -1.0f,     1.0f,  0.0f,
        0.5f,  0.5f, -0.5f,     0.0f,  0.0f, -1.0f,     1.0f,  1.0f,
        0.5f,  0.5f, -0.5f,     0.0f,  0.0f, -1.0f,     1.0f,  1.0f,
        -0.5f,  0.5f, -0.5f,    0.0f,  0.0f, -1.0f,     0.0f,  1.0f,
        -0.5f, -0.5f, -0.5f,    0.0f,  0.0f, -1.0f,     0.0f,  0.0f,
        
        -0.5f, -0.5f,  0.5f,    0.0f,  0.0f,  1.0f,     0.0f,  0.0f,
        0.5f, -0.5f,  0.5f,     0.0f,  0.0f,  1.0f,     1.0f,  0.0f,
        0.5f,  0.5f,  0.5f,     0.0f,  0.0f,  1.0f,     1.0f,  1.0f,
        0.5f,  0.5f,  0.5f,     0.0f,  0.0f,  1.0f,      1.0f,  1.0f,
        -0.5f,  0.5f,  0.5f,    0.0f,  0.0f,  1.0f,     0.0f,  1.0f,
        -0.5f, -0.5f,  0.5f,    0.0f,  0.0f,  1.0f,     0.0f,  0.0f,
        
        -0.5f,  0.5f,  0.5f,    -1.0f,  0.0f,  0.0f,    1.0f,  0.0f,
        -0.5f,  0.5f, -0.5f,    -1.0f,  0.0f,  0.0f,    1.0f,  1.0f,
        -0.5f, -0.5f, -0.5f,    -1.0f,  0.0f,  0.0f,    0.0f,  1.0f,
        -0.5f, -0.5f, -0.5f,    -1.0f,  0.0f,  0.0f,    0.0f,  1.0f,
        -0.5f, -0.5f,  0.5f,    -1.0f,  0.0f,  0.0f,    0.0f,  0.0f,
        -0.5f,  0.5f,  0.5f,    -1.0f,  0.0f,  0.0f,    1.0f,  0.0f,
        
        0.5f,  0.5f,  0.5f,     1.0f,  0.0f,  0.0f,     1.0f,  0.0f,
        0.5f,  0.5f, -0.5f,     1.0f,  0.0f,  0.0f,     1.0f,  1.0f,
        0.5f, -0.5f, -0.5f,     1.0f,  0.0f,  0.0f,     0.0f,  1.0f,
        0.5f, -0.5f, -0.5f,     1.0f,  0.0f,  0.0f,     0.0f,  1.0f,
        0.5f, -0.5f,  0.5f,     1.0f,  0.0f,  0.0f,     0.0f,  0.0f,
        0.5f,  0.5f,  0.5f,     1.0f,  0.0f,  0.0f,     1.0f,  0.0f,
        
        -0.5f, -0.5f, -0.5f,    0.0f, -1.0f,  0.0f,     0.0f,  1.0f,
        0.5f, -0.5f, -0.5f,     0.0f, -1.0f,  0.0f,     1.0f,  1.0f,
        0.5f, -0.5f,  0.5f,     0.0f, -1.0f,  0.0f,     1.0f,  0.0f,
        0.5f, -0.5f,  0.5f,     0.0f, -1.0f,  0.0f,     1.0f,  0.0f,
        -0.5f, -0.5f,  0.5f,    0.0f, -1.0f,  0.0f,     0.0f,  0.0f,
        -0.5f, -0.5f, -0.5f,    0.0f, -1.0f,  0.0f,     0.0f,  1.0f,
        
        -0.5f,  0.5f, -0.5f,    0.0f,  1.0f,  0.0f,     0.0f,  1.0f,
        0.5f,  0.5f, -0.5f,     0.0f,  1.0f,  0.0f,     1.0f,  1.0f,
        0.5f,  0.5f,  0.5f,     0.0f,  1.0f,  0.0f,     1.0f,  0.0f,
        0.5f,  0.5f,  0.5f,     0.0f,  1.0f,  0.0f,     1.0f,  0.0f,
        -0.5f,  0.5f,  0.5f,    0.0f,  1.0f,  0.0f,     0.0f,  0.0f,
        -0.5f,  0.5f, -0.5f,    0.0f,  1.0f,  0.0f,     0.0f,  1.0f
    };
    
    //!!!automatical generation algorithm is still in development... sorry for hardcoding
    //all box positions
    glm::vec3 cubePositions[] = {
        glm::vec3(0.0f, -5.0f, 0.0f),
        glm::vec3(22.0f, -5.0f, -15.0f),
        glm::vec3(-21.5f, -5.0f, 6.5f),
        glm::vec3(-15.8f, -5.0f, -12.3f),
        glm::vec3(23.4f, -5.0f, 5.5f),
        glm::vec3(-31.7f, -5.0f, -17.5f),
        glm::vec3(41.3f, -5.0f, -23.5f),
        glm::vec3(51.5f, -5.0f, -22.3f),
        glm::vec3(61.11f, -5.0f, -12.13f),
        glm::vec3(-4.0f, -5.0f, -26.2f),
        //10
        
        glm::vec3(-5.0f, -5.0f, 15.0f),
        glm::vec3(5.0f, -5.0f, -35.0f),
        glm::vec3(-1.5f, -5.0f, 26.5f),
        glm::vec3(-15.8f, -5.0f, -30.3f),
        glm::vec3(10.4f, -5.0f, 5.5f),
        glm::vec3(-21.7f, -5.0f, 17.5f),
        glm::vec3(-41.3f, -5.0f, -43.5f),
        glm::vec3(51.5f, -5.0f, 5.3f),
        glm::vec3(61.11f, -5.0f, 2.13f),
        glm::vec3(-25.0f, -5.0f, 61.2f),
        //10
        
        glm::vec3(-12.0f, 4.0f, 12.0f),
        glm::vec3(-14.0f, 5.0f, 14.0f)
        //2
    };
    
    //cubes on the screen will be scaled according to those values
    glm::vec3 cubeScales[] = {
        //first 20 are big cubes that we can step on (well, not yet)
        glm::vec3(8.0f, 8.0f, 8.0f),
        glm::vec3(8.0f, 8.0f, 8.0f),
        glm::vec3(6.0f, 8.0f, 6.0f),
        glm::vec3(2.0f, 8.0f, 4.0f),
        glm::vec3(8.0f, 8.0f, 6.0f),
        glm::vec3(8.0f, 8.0f, 8.0f),
        glm::vec3(2.0f, 8.0f, 6.0f),
        glm::vec3(4.0f, 8.0f, 2.0f),
        glm::vec3(10.0f, 8.0f, 4.0f),
        glm::vec3(4.0f, 8.0f, 9.0f),
        //10

        glm::vec3(8.0f, 8.0f, 8.0f),
        glm::vec3(7.0f, 8.0f, 8.0f),
        glm::vec3(7.0f, 8.0f, 10.0f),
        glm::vec3(6.0f, 8.0f, 7.0f),
        glm::vec3(5.0f, 8.0f, 7.0f),
        glm::vec3(4.0f, 8.0f, 6.0f),
        glm::vec3(5.0f, 8.0f, 5.0f),
        glm::vec3(6.0f, 8.0f, 7.0f),
        glm::vec3(10.0f, 8.0f, 8.0f),
        glm::vec3(14.0f, 8.0f, 4.0f),
        //10
        
        glm::vec3(1.0f),
        glm::vec3(1.0f),
        glm::vec3(1.0f),
        glm::vec3(1.0f),
        glm::vec3(1.0f),
        glm::vec3(1.0f),
        glm::vec3(1.0f),
        glm::vec3(1.0f),
        glm::vec3(1.0f),
        glm::vec3(1.0f),
        //10
        
        glm::vec3(1.0f),
        glm::vec3(1.0f),
        glm::vec3(1.0f),
        glm::vec3(1.0f),
        glm::vec3(1.0f),
        glm::vec3(1.0f),
        glm::vec3(1.0f),
        glm::vec3(1.0f),
        glm::vec3(1.0f),
        glm::vec3(1.0f)
        //10
        
    };
    
    //cubes color are generated automatiaclly (r,g,b values are a random float number between 0 and 1)
    glm::vec3 cubesColor[NUMBER_OF_CUBES];
    generateCubesColor(cubesColor);
    
    //cube rotations are generated automatically (with a variance set by the programmer in #define section)
    GLfloat cubesRotationVariance[NUMBER_OF_CUBES];
    generateCubesRotationVariance(cubesRotationVariance);
    
    //cube rotation axis are generated automatically (with a variance set by the programmer in #define section)
    glm::vec3 cubesRotationAxis[NUMBER_OF_CUBES];
    generateCubesRotationAxis(cubesRotationAxis);
    
    //all point lights positions
    //automatical generation algorithm
    glm::vec3 pointLightPositions[NUMBER_OF_LANTERNS];
    generateLanternPositions(pointLightPositions);
    
    //lanterns are floating in a sinusoidal function. this table is filled with values that determine how much we want to change the default floating variance
    GLfloat pointLightSinusoidalVariance[NUMBER_OF_LANTERNS];
    generateLanternSinudoidalVariance(pointLightSinusoidalVariance);
    
    //position values that are sent to the shader
    GLfloat skyboxVertices[] = {
        // Positions
        -1.0f,  1.0f, -1.0f,
        -1.0f, -1.0f, -1.0f,
        1.0f, -1.0f, -1.0f,
        1.0f, -1.0f, -1.0f,
        1.0f,  1.0f, -1.0f,
        -1.0f,  1.0f, -1.0f,
        
        -1.0f, -1.0f,  1.0f,
        -1.0f, -1.0f, -1.0f,
        -1.0f,  1.0f, -1.0f,
        -1.0f,  1.0f, -1.0f,
        -1.0f,  1.0f,  1.0f,
        -1.0f, -1.0f,  1.0f,
        
        1.0f, -1.0f, -1.0f,
        1.0f, -1.0f,  1.0f,
        1.0f,  1.0f,  1.0f,
        1.0f,  1.0f,  1.0f,
        1.0f,  1.0f, -1.0f,
        1.0f, -1.0f, -1.0f,
        
        -1.0f, -1.0f,  1.0f,
        -1.0f,  1.0f,  1.0f,
        1.0f,  1.0f,  1.0f,
        1.0f,  1.0f,  1.0f,
        1.0f, -1.0f,  1.0f,
        -1.0f, -1.0f,  1.0f,
        
        -1.0f,  1.0f, -1.0f,
        1.0f,  1.0f, -1.0f,
        1.0f,  1.0f,  1.0f,
        1.0f,  1.0f,  1.0f,
        -1.0f,  1.0f,  1.0f,
        -1.0f,  1.0f, -1.0f,
        
        -1.0f, -1.0f, -1.0f,
        -1.0f, -1.0f,  1.0f,
        1.0f, -1.0f, -1.0f,
        1.0f, -1.0f, -1.0f,
        -1.0f, -1.0f,  1.0f,
        1.0f, -1.0f,  1.0f
    };
    
/*
     ===========================================
     ============== box buffers ================
     ===========================================
*/
    GLuint VBO, boxVAO;
    glGenVertexArrays(1, &boxVAO);
    glGenBuffers(1, &VBO);
    
    glBindVertexArray(boxVAO);
    
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
    
    
    //position attibute
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat), (GLvoid*) 0);
    glEnableVertexAttribArray(0);
    
    //normal attribute
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat), (GLvoid*) (3 * sizeof(GLfloat)));
    glEnableVertexAttribArray(1);
    
    //texture attribute
    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat), (GLvoid*) (6 * sizeof(GLfloat)));
    glEnableVertexAttribArray(2);
    
    //unbing VAO
    glBindVertexArray(0);
    
    /*
     ===========================================
     ========== end of box buffers =============
     ===========================================
     */
    
    
    /*
     ===========================================
     ============= light buffers ===============
     ===========================================
     */
    
    GLuint lightVAO;
    glGenVertexArrays(1, &lightVAO);
    glGenBuffers(1, &VBO);
    
    glBindVertexArray(lightVAO);
    
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
    
    //position attibute
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat), (GLvoid*) 0);
    glEnableVertexAttribArray(0);
    
    //unbing VAO
    glBindVertexArray(0);
    
    /*
     ===========================================
     ========== end of light buffers ===========
     ===========================================
     */
    
    /*
     ===========================================
     ============= skybox buffers ==============
     ===========================================
     */
    
    GLuint skyboxVBO, skyboxVAO;
    glGenVertexArrays(1, &skyboxVAO);
    glGenBuffers(1, &skyboxVBO);
    glBindVertexArray(skyboxVAO);
    glBindBuffer(GL_ARRAY_BUFFER, skyboxVBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(skyboxVertices), &skyboxVertices, GL_STATIC_DRAW);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3*sizeof(GLfloat), (GLvoid *) 0);
    glBindVertexArray(0);
    
    
    /*
     ===========================================
     ========= end of skybox buffers ===========
     ===========================================
     */
    
    /*
     ==========================================
     ========== creating textures =============
     ==========================================
     */
    
    GLuint diffuseMap, specularMap, pixelated;
    glGenTextures(1, &diffuseMap);
    glGenTextures(1, &specularMap);
    glGenTextures(1, &pixelated);
    
    int textureWidth, textureHeight;
    unsigned char *image;
    
    //diffuse map
    diffuseMap = Texture::assignTexture("resources/images/metal-wood.jpg");
    
    //specular map
    specularMap = Texture::assignTexture("resources/images/metal-parts.jpg");
    
    //abstract texture
    pixelated = Texture::assignTexture("resources/images/solid.png");
    
    _lightShader.use();
    glUniform1i(glGetUniformLocation(_lightShader.Program, "u_material.diffuse"),   0);
    glUniform1i(glGetUniformLocation(_lightShader.Program, "u_material.specular"), 1);
    
    //skybox
    std::vector<const GLchar *> faces;
    
    //nightsky texture
    faces.push_back("resources/skybox/nightsky_west.bmp");
    faces.push_back("resources/skybox/nightsky_east.bmp");
    faces.push_back("resources/skybox/nightsky_up.bmp");
    faces.push_back("resources/skybox/nightsky_down.bmp");
    faces.push_back("resources/skybox/nightsky_south.bmp");
    faces.push_back("resources/skybox/nightsky_north.bmp");
    
    /*
    //galaxy texture
    //contribution to hackcraft.de
    /https://opengameart.org/content/galaxy-skybox
    faces.push_back("resources/galaxy/galaxy+X.tga");
    faces.push_back("resources/galaxy/galaxy-Y.tga");
    faces.push_back("resources/galaxy/galaxy+Z.tga");
    faces.push_back("resources/galaxy/galaxy-Y.tga");
    faces.push_back("resources/galaxy/galaxy-Y.tga");
    faces.push_back("resources/galaxy/galaxy-X.tga");
    //*/

    GLuint skyboxTexture = Texture::assignSkybox(faces);
    
/*
     ==========================================
     ======= end of  creating textures ========
     ==========================================
*/
    
    //projection matrix used to present objects in our perspective (P * V * M)
    glm::mat4 projection = glm::perspective(camera.getZoom(), (GLfloat) SCREEN_WIDTH/(GLfloat) SCREEN_HEIGHT, 0.1f, 1000.0f);

    
// <> <> <> <> --------------------------------------------------------------------------- <> <> <> <>
// <> <> <> <> <> <> <> <> ----------------- GAME LOOP ---------------------<> <> <> <> <> <> <> <> <>
// <> <> <> <> --------------------------------------------------------------------------- <> <> <> <>
    while(!glfwWindowShouldClose(window)) {
        //measure the time between the last frame and the current frame (deltatime)
        deltaTime = updateTime();
        
        //third distortion: camera disturbance
        if (kinTime >= KIN_DISTURBANCE_ACTIVATION_TIME) {
            camera.processMouseMovement(kinDisturbanceCounter * (((GLfloat) rand() / (GLfloat) RAND_MAX) * KIN_CAMERA_DISTURBANCE_VARIANCE - KIN_CAMERA_DISTURBANCE_VARIANCE/2), kinDisturbanceCounter * (((GLfloat) rand() / (GLfloat) RAND_MAX) * KIN_CAMERA_DISTURBANCE_VARIANCE - KIN_CAMERA_DISTURBANCE_VARIANCE/2));
        }
        
        //check for any events (keyboard / mouse input)
        glfwPollEvents();
        
        //move specific positions on the scene according the the input given
        doMovement(window);
        
        //clear the colorbuffer
        glClearColor(0.0f, 0.0f, 0.0f, 0.0f);   //might as well be 100% white, since we're using skybox anyway
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        
        //prepare box shading
        _lightShader.use();
        
        //there are many light attributes that can change the scene. however, since there are too many combinations, I'm not putting them in #define section. If you want to change any of it, do it here.
 
        //directional light
        glUniform3f(glGetUniformLocation(_lightShader.Program, "u_viewPos"), camera.getPosition().x, camera.getPosition().y, camera.getPosition().z);
        glUniform1f(glGetUniformLocation(_lightShader.Program,"u_material.shininess"), DEFAULT_SHININESS);
        glUniform3f(glGetUniformLocation(_lightShader.Program, "u_dirLight.direction"), 0.7f, -0.9f, 0.1f);
        glUniform3f(glGetUniformLocation(_lightShader.Program, "u_dirLight.ambient"), 0.9f, 0.9f, 0.9f);
        glUniform3f(glGetUniformLocation(_lightShader.Program, "u_dirLight.diffuse"), 0.3f, 0.3f, 0.3f);
        glUniform3f(glGetUniformLocation(_lightShader.Program, "u_dirLight.specular"), 0.0f, 0.00f, 0.0f);

        // -------- POINT LIGHTS (posiions of those point lights are specified by pointLightPositions (line 175)
        //point light 0
        glUniform3f(glGetUniformLocation(_lightShader.Program, "u_pointLights[0].position"), pointLightPositions[0].x, pointLightPositions[0].y, pointLightPositions[0].z);
        glUniform3f(glGetUniformLocation(_lightShader.Program, "u_pointLights[0].ambient"), 0.7f, 0.7f, 0.7f);
        glUniform3f(glGetUniformLocation(_lightShader.Program, "u_pointLights[0].diffuse"), 1.0f, 0.7f, 0.7f);
        glUniform3f(glGetUniformLocation(_lightShader.Program, "u_pointLights[0].specular"), 1.0f, 0.7f, 0.7f);
        glUniform1f(glGetUniformLocation(_lightShader.Program, "u_pointLights[0].constant"), 1.0f);
        glUniform1f(glGetUniformLocation(_lightShader.Program, "u_pointLights[0].linear"), 1.0f);
        glUniform1f(glGetUniformLocation(_lightShader.Program, "u_pointLights[0].quadratic"), 1.0f);
        
        //point light 1
        glUniform3f(glGetUniformLocation(_lightShader.Program, "u_pointLights[1].position"), pointLightPositions[1].x, pointLightPositions[1].y, pointLightPositions[1].z);
        glUniform3f(glGetUniformLocation(_lightShader.Program, "u_pointLights[1].ambient"), 0.905f, 0.905f, 0.905f);
        glUniform3f(glGetUniformLocation(_lightShader.Program, "u_pointLights[1].diffuse"), 0.805f, 0.805f, 0.805f);
        glUniform3f(glGetUniformLocation(_lightShader.Program, "u_pointLights[1].specular"), 1.0f, 1.0f, 1.0f);
        glUniform1f(glGetUniformLocation(_lightShader.Program, "u_pointLights[1].constant"), 1.0f);
        glUniform1f(glGetUniformLocation(_lightShader.Program, "u_pointLights[1].linear"), 0.90f);
        glUniform1f(glGetUniformLocation(_lightShader.Program, "u_pointLights[1].quadratic"), 0.50f);
        
        //point light 2
        glUniform3f(glGetUniformLocation(_lightShader.Program, "u_pointLights[2].position"), pointLightPositions[2].x, pointLightPositions[2].y, pointLightPositions[2].z);
        glUniform3f(glGetUniformLocation(_lightShader.Program, "u_pointLights[2].ambient"), 0.905f, 0.905f, 0.905f);
        glUniform3f(glGetUniformLocation(_lightShader.Program, "u_pointLights[2].diffuse"), 0.805f, 0.805f, 0.805f);
        glUniform3f(glGetUniformLocation(_lightShader.Program, "u_pointLights[2].specular"), 1.0f, 1.0f, 1.0f);
        glUniform1f(glGetUniformLocation(_lightShader.Program, "u_pointLights[2].constant"), 1.0f);
        glUniform1f(glGetUniformLocation(_lightShader.Program, "u_pointLights[2].linear"), 0.90f);
        glUniform1f(glGetUniformLocation(_lightShader.Program, "u_pointLights[2].quadratic"), 0.50f);
        
        //point light 3
        glUniform3f(glGetUniformLocation(_lightShader.Program, "u_pointLights[3].position"), pointLightPositions[3].x, pointLightPositions[3].y, pointLightPositions[3].z);
        glUniform3f(glGetUniformLocation(_lightShader.Program, "u_pointLights[3].ambient"), 0.05f, 0.05f, 0.05f);
        glUniform3f(glGetUniformLocation(_lightShader.Program, "u_pointLights[3].diffuse"), 0.805f, 0.805f, 0.805f);
        glUniform3f(glGetUniformLocation(_lightShader.Program, "u_pointLights[3].specular"), 1.0f, 1.0f, 1.0f);
        glUniform1f(glGetUniformLocation(_lightShader.Program, "u_pointLights[3].constant"), 1.0f);
        glUniform1f(glGetUniformLocation(_lightShader.Program, "u_pointLights[3].linear"), 0.90f);
        glUniform1f(glGetUniformLocation(_lightShader.Program, "u_pointLights[3].quadratic"), 0.50f);
        
        //spot light
        glUniform3f(glGetUniformLocation(_lightShader.Program, "u_spotLight.position"), camera.getPosition().x, camera.getPosition().y, camera.getPosition().z);
        glUniform3f(glGetUniformLocation(_lightShader.Program, "u_spotLight.direction"), camera.getFront().x, camera.getFront().y, camera.getFront().z);
        glUniform3f(glGetUniformLocation(_lightShader.Program, "u_spotLight.ambient"), 0.005f, 0.005f, 0.005f);
        glUniform3f(glGetUniformLocation(_lightShader.Program, "u_spotLight.diffuse"), 0.005f, 0.005f, 0.005f);
        glUniform3f(glGetUniformLocation(_lightShader.Program, "u_spotLight.specular"), 0.005f, 0.005f, 0.005f);
        glUniform1f(glGetUniformLocation(_lightShader.Program, "u_spotLight.constant"), 0.005f);
        glUniform1f(glGetUniformLocation(_lightShader.Program, "u_spotLight.linear"), 0.005f);
        glUniform1f(glGetUniformLocation(_lightShader.Program, "u_spotLight.quadratic"), 0.005f);
        glUniform1f(glGetUniformLocation(_lightShader.Program, "u_spotLight.cutOFf"), glm::cos(glm::radians(12.5f)));
        glUniform1f(glGetUniformLocation(_lightShader.Program, "u_spotLight.outerCutOFf"), glm::cos(glm::radians(15.5f)));
    
        
        //set uniform locations for cubes (_lightShader)
        glm::mat4 view = camera.getViewMatrix();
        GLint modelLocation = glGetUniformLocation(_lightShader.Program, "u_model");
        glUniformMatrix4fv(glGetUniformLocation(_lightShader.Program, "u_view"), 1, GL_FALSE, glm::value_ptr(view));
        glUniformMatrix4fv(glGetUniformLocation(_lightShader.Program, "u_projection"), 1, GL_FALSE, glm::value_ptr(projection));
        
        //drawing cubes
        glm::mat4 model;
        glBindVertexArray(boxVAO);
        
        for (GLuint i = 0; i < NUMBER_OF_CUBES; i++) {
            //set specular map
            glActiveTexture(GL_TEXTURE1);
            
            //big cubes
            if (i < 20)
                glBindTexture(GL_TEXTURE_2D, 0);
            else
                glBindTexture(GL_TEXTURE_2D, specularMap);
            
            //set diffuse map
            glActiveTexture(GL_TEXTURE0);
            
            //big cubes
            if (i < 20)
                glBindTexture(GL_TEXTURE_2D, pixelated);
            else
                glBindTexture(GL_TEXTURE_2D, diffuseMap);
            
            //what texture do we use
            glUniform1i(glGetUniformLocation(_lightShader.Program, "u_textureLess"), cubesColor[i] == glm::vec3(1.0f) ? false : true);
            glUniform3f(glGetUniformLocation(_lightShader.Program, "u_cubeColor"), cubesColor[i].r, cubesColor[i].g, cubesColor[i].b);
            
            
            model = glm::mat4();
            model = glm::translate(model, cubePositions[i]);
            model = glm::scale(model, cubeScales[i]);
            model = glm::rotate(model, cubesRotationVariance[i] * kinRotationCounter * deltaTime, cubesRotationAxis[i]);
            
            //let's move those crates out of our sight
            if (i >= HOW_MANY_BIG_CUBES)
                model = glm::translate(model, glm::vec3(40.f, 0.0f, 30.0f));
            glUniformMatrix4fv(modelLocation, 1, GL_FALSE, glm::value_ptr(model));
            
            glDrawArrays(GL_TRIANGLES, 0, 36);
        }
        
        glBindVertexArray(0);
        
        
        //set uniform locations for lanterns (point lights' physical form) - _lanternShader
        _lanternShader.use();
        modelLocation = glGetUniformLocation(_lanternShader.Program, "u_model");
        glUniformMatrix4fv(glGetUniformLocation(_lanternShader.Program, "u_view"), 1, GL_FALSE, glm::value_ptr(view));
        glUniformMatrix4fv(glGetUniformLocation(_lanternShader.Program, "u_projection"), 1, GL_FALSE, glm::value_ptr(projection));
        
        glBindVertexArray(lightVAO);
        
        //drawing point lights
        for (GLuint i = 0; i < NUMBER_OF_LANTERNS; i++) {
            model = glm::mat4();
            model = glm::translate(model, pointLightPositions[i]);
            model = glm::translate(model, lightPos);
            model = glm::translate(model, glm::vec3(0.0f, cos(glfwGetTime() * pointLightSinusoidalVariance[i]) * (kinfolkMode? kinTime*KIN_MODE_LANTERN_ACCELERATION:1.0f), 0.0f));
            model = glm::scale(model, glm::vec3(LANTERN_SIZE));
            glUniformMatrix4fv(modelLocation, 1, GL_FALSE, glm::value_ptr(model));
            glDrawArrays(GL_TRIANGLES, 0, 36);
        }
        glBindVertexArray(0);
        
        
        //draw skybox
        glDepthFunc(GL_LEQUAL);          //this changes the depth function so the depth test passes when values are equal to the depth buffer content
        _skyboxShader.use();
        view = glm::mat4(glm::mat3(camera.getViewMatrix( )));    // Remove any translation component of the view matrix
        projection = glm::perspective(camera.getZoom( ), (float)SCREEN_WIDTH/(float)SCREEN_HEIGHT, 0.1f, 1000.0f);
        
        glUniformMatrix4fv(glGetUniformLocation(_skyboxShader.Program, "u_view"), 1, GL_FALSE, glm::value_ptr(view));
        glUniformMatrix4fv(glGetUniformLocation(_skyboxShader.Program, "u_projection"), 1, GL_FALSE, glm::value_ptr(projection));
        
        glBindVertexArray(skyboxVAO);
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_CUBE_MAP, skyboxTexture);
        glDrawArrays(GL_TRIANGLES, 0, 36);
        glBindVertexArray(0);
        glDepthFunc(GL_LESS);           //set it back to default
        

        glfwSwapBuffers(window);

    }
    
    
    glDeleteVertexArrays(1, &boxVAO);
    glDeleteVertexArrays(1, &lightVAO);
    glDeleteVertexArrays(1, &skyboxVAO);
    glDeleteVertexArrays(1, &skyboxVBO);
    glDeleteBuffers(1, &VBO);
    
    Mix_FreeMusic(soundTrack);
    Mix_CloseAudio();
    
    glfwTerminate();
    return 0;
}



void generateLanternPositions(glm::vec3 *pointLightPositions) {
    GLint signX = 1;
    GLint signZ = 1;
    GLfloat positionCounterX = 0.0f;
    GLfloat positionCounterZ = 0.0f;
    GLuint counter = 0;             //when to change signX and signY
    GLfloat varietyX, varietyY, varietyZ;
    
    //there are four sections of lanterns (++) (-+) (--) (+-)
    for (int i = 0; i < 4; i++) {
        positionCounterX = 0.0f;
        positionCounterZ = 0.0f;
        switch (i) {
            case 0: signX = 1; signZ = 1; break;
            case 1: signX = -1; signZ = 1; break;
            case 2: signX = -1; signZ = -1; break;
            case 3: signX = 1; signZ = -1; break;
        }
        //loop for every individual section
        for (int j = 0; j < NUMBER_OF_LANTERNS/4; j++) {
            //after one row is filled, move to the next one
            if (++counter >= sqrt(NUMBER_OF_LANTERNS/16)) {
                counter = 0;
                positionCounterX = 0.0f;
                positionCounterZ += LANTERN_SPREAD;
            }
            
            //variation is applied to each individual position argument
            varietyX = rand() % (VARIETY_RANGE + 1);
            varietyY = rand() % (VARIETY_RANGE + 1);
            varietyZ = rand() % (VARIETY_RANGE + 1);
            pointLightPositions[i * NUMBER_OF_LANTERNS/4 + j] = glm::vec3(signX * positionCounterX + varietyX,  STARTING_LANTERN_HEIGHT + varietyY + 2.0f, signZ * positionCounterZ + varietyZ);
            
            positionCounterX += LANTERN_SPREAD;
        }
    }
}

void generateLanternSinudoidalVariance(GLfloat *pointLightSinusoidalVariance) {
    for (int i = 0; i < NUMBER_OF_LANTERNS; i++) {
        pointLightSinusoidalVariance[i] = (rand() % (LANTERN_FLOATING_SPEED + 1))*0.1f;
    }
}

void generateCubesColor(glm::vec3 *cubesColor) {
    for (int i = 0; i < NUMBER_OF_CUBES; i++) {
        if (i >= HOW_MANY_BIG_CUBES -1) {
            cubesColor[i] = glm::vec3(1.0f);
            continue;
        }
        cubesColor[i] = glm::vec3(((GLfloat) rand() / (GLfloat) RAND_MAX), ((GLfloat) rand() / (GLfloat) RAND_MAX), ((GLfloat) rand() / (GLfloat) RAND_MAX));
    }
}

void generateCubesRotationAxis(glm::vec3 *cubesRotationAxis) {
    for (int i = 0; i < NUMBER_OF_CUBES; i++) {
        cubesRotationAxis[i] = glm::vec3(((GLfloat) rand() / (GLfloat) RAND_MAX) * 2.0f - 1.0f, ((GLfloat) rand() / (GLfloat) RAND_MAX) * 2.0f - 1.0f, ((GLfloat) rand() / (GLfloat) RAND_MAX) * 2.0f - 1.0f);
    }
}

void generateCubesRotationVariance(GLfloat *cubesRotationVariance) {
    for (int i = 0; i < NUMBER_OF_CUBES; i++) {
        cubesRotationVariance[i] = ((GLfloat) rand() / (GLfloat) RAND_MAX) * CUBE_BASE_ROTATION_ANGLE - CUBE_BASE_ROTATION_ANGLE/2.0f;
    }
}



GLfloat updateTime() {
    GLfloat currentTime = glfwGetTime();
    GLfloat delta = currentTime - lastTime;
    lastTime = currentTime;
    if (kinfolkMode)
        kinTime += delta;
    else
        kinTime = 0.0f;
    if (kinTime >= 0.5f & !kinMusicActivated) {
        Mix_HaltMusic();
        Mix_FadeInMusic(shepardRissetGlissando, -1, 2000);
        kinMusicActivated = true;
    }
    kinRotatingActivated = kinTime >= KIN_ROTATING_ACTIVATION_TIME? true:false;
    kinDisturbanceActivated = kinTime >= KIN_DISTURBANCE_ACTIVATION_TIME? true:false;
    if (kinTime >= KIN_ROTATING_ACTIVATION_TIME)
        kinRotationCounter += CUBE_ROTATION_ACCELARATION;
    else
        kinRotationCounter = 0.0f;
    if (kinTime >= KIN_DISTURBANCE_ACTIVATION_TIME && kinDisturbanceCounter <= KIN_CAMERA_DISTURBANCE_MAX_VALUE)
        kinDisturbanceCounter += KIN_CAMERA_DISTURBANCE_ACCELERATION;
    else
        kinDisturbanceCounter = 0.0f;
    
    return delta;
}

void doMovement(GLFWwindow *window) {
    if (keys[GLFW_KEY_W] || keys[GLFW_KEY_UP]) {
        camera.processKeyboard(FORWARD, deltaTime);
    }
    if (keys[GLFW_KEY_S] || keys[GLFW_KEY_DOWN]) {
        camera.processKeyboard(BACKWARD, deltaTime);
    }
    if (keys[GLFW_KEY_A] || keys[GLFW_KEY_LEFT]) {
        camera.processKeyboard(LEFT, deltaTime);
    }
    if (keys[GLFW_KEY_D] || keys[GLFW_KEY_RIGHT]) {
        camera.processKeyboard(RIGHT, deltaTime);
    }
    if (keys[GLFW_KEY_X]) {
        //change mode to be able to put portals
        if (!kinfolkMode) {
            kinTime = 0.0f;
            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
            glfwSwapBuffers(window);
            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
            glfwSwapBuffers(window);
            glColorMask(GL_TRUE, GL_FALSE, GL_TRUE, GL_TRUE);
            kinfolkMode = true;
            Mix_FadeOutMusic(500);
            kinMusicActivated = false;
        }
        
    }
    if (keys[GLFW_KEY_C]) {
        if (kinfolkMode) {
            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
            glfwSwapBuffers(window);
            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
            glfwSwapBuffers(window);
            glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
            kinfolkMode = false;
            Mix_FadeInMusic(soundTrack, -1, 1000);
        }
    }
}

void keyCallback(GLFWwindow *window, int key, int scancode, int action, int mode) {
    if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS) {
        glfwSetWindowShouldClose(window, GL_TRUE);
    }
    if (key >= 0 && key < 1024) {
        if (GLFW_PRESS == action) {
            keys[key] = true;
        }
        else if (GLFW_RELEASE == action) {
            keys[key] = false;
        }
    }
}

void mouseCallback(GLFWwindow *window, double xPos, double yPos) {
    if (firstMouse) {
        lastX = xPos;
        lastY = yPos;
        firstMouse = false;
    }
    
    GLfloat xOffset = xPos - lastX;
    GLfloat yOffset = lastY - yPos;         //reverse it because y coordinate is inversed by default
    
    //update current values
    lastX = xPos;
    lastY = yPos;
    
    camera.processMouseMovement(xOffset, yOffset);
}

void initSystems(){
    glfwInit();
    
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);            //for mac
    glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);                       //disable window size change
    
    srand((unsigned)time(0));                                       //random number generator
}


